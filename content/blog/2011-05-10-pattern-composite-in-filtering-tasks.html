{% extends '_post.html' %}

{% hyde
    title: DDD подход к решению задачи сложной фильтрации данных
    created: 2011-06-01
    published: False
    categories: Архитектура, Практика DDD
    display_in_list: False
    snip: "Эта заметка представляет из себя некую выборку идей и подходов к организации сложной фильтрации и кастомизированного поиска, которые я использую в своем проекте. Пишу по многочисленным просьбам (здесь и здесь). Все подходы описаны на конкретном примере, очень распространенном в практике создания веб-приложений. Приведенный код в большинстве своем является условным и чисто-показательным, но частично изъят из боевых окружения."
%}

{% block article %}
### 1. Постановка задачи

Давайте рассмотрим типичную ситуацию на типичном веб-проекте: социальная сеть для любителей литературы предоставляет своим пользователям удобный расширенный поиск, содержащий такие поля, как:
- ISBN
- название (точное или по частичному совпадению)
- автор произведения
- издатель
- год издания (переиздания)
- язык (основной и переводы)
- жанр
- тематическая категория (или теги)
- электронная версия (да/нет)
- рейтинг по оценкам других пользователей
- популярность по пользовательским просмотрам (или комментариям)
- ... другие критерии

Здесь хочу сразу подчеркнуть одну важную для проектирования тонкость: все критерии кроме двух последних про пользователей касаются некоторых характеристик Книги (Book), т.е неотделимы от этого доме. А вот два последних не являются характеристиками книги, а представляют из себя условия на _Ассоциации_ между доменом Books и доменом Users. В случае простых business rules на каждом из доменов ничего страшного не случится, но подобные вещи все равно нужно заранее "видеть", понимать, анализировать и делать на них явный акцент в коде - потому что это первые претенденты на то, чтобы стать источником проблем междоменного взаимодействия (которое обычно слабо покрыто тестами из-за интеграционной сути действия объектов).

С какими техническими здаачами вам придется столкнуться для реализации данного функционала:
- создать форму с большим количество UI элементов под каждый из критериев (вопрос удобства и юзабельности мы сейчас не рассматриваем)
- принять запрос на поиск от пользователя в виде GET (POST?) запроса (get очевидно удобнее для открытых поисковых систем)
- провалидировать каждый из этих поисковых критериев
- в случае валидности запроса передать список этих критериев на уровень ниже и выбрать данные из БД
- в случае невалидности запроса показать пользователю список ошибок
- отрендерить форму с конкретными значениями по каждому критерию
- показать результат поиска (эта задача технически существует, но мы пока рассматриваем только вышестоящие)

В принципе, этот список с некоторомыми поправками будет актуален для любой обработки запросов пользователей, сформированных с веб-формы. Ничего необычного в этих задачах нет. Вопрос в том, что каждый из отдельных критериев полученных в запросе требует отдельной, зачастую специфичной, обработки - это приводит к тому, что количество кода растет очень быстро. И если не использовать какую-нибудь логичную систему организации этого кода, то постепенно будет получатся лапша, которую сложно сопровождать и дополнять.

Сейчас мы попробуем сформировать именно такую систему. Какие цели будут стоять перед нами:
- снизить до нуля дублирование кода
- максимально приблизится к SOLID, разбивая код на небольшие и абсолютно прозрачные куски функционала
- добится реюзабельности написанного кода в других частях приложения (и даже в других приложениях)
- обеспечить максимальную простоту добавления новых критериев, а также внесение изменений в обработку существующих
- полностью абстрагироваться от персистеного хранилища (БД и др.), так чтобы мы имели возможность менять схему храния данных с минимальными изменениям в коде

Небольшой комментарий к последнему пункту. Здесь имеется ввиду не только возможность быстро сменить базу данных с MySQL на какое-нибудь noSQL решение. Здесь мы говорим о простой возможности реализовать и менять хранение данных: от мелкой смены названия колонок в таблицах базы данных, до вынесения поисковой логики на Sphinx или другой поисковый демон.

Давайте теперь проанализируем классический подход к решению таких задач (в рамках zf application) и посмотрим на те проблемы, которые в этом случае возникают.

### 2. Классическая схема решения

Давайте посмотрим на типичное "ручное" решение этой задачи средствами Zend Framework.

**Zend_Form**

Скорее всего, у нас будет некоторая форма

    // application/forms/BookSearch.php
    class Form_BookSearch extends Zend_Form
    {
        public function init()
        {
            $this->setAction('/book/search');
            $this->setMethod(Zend_Form::METHOD_POST);

            // добавляем элементы
            $this->isbn  = new Zend_Form_Element_Text('isbn');
            $this->title = new Zend_Form_Element_Text('title');
            $this->author = new Zend_Form_Element_Text('author');

            // .. другие элементы

            $this->year  = new Zend_Form_Element_Select('year');
            $this->genre = new Zend_Form_Element_Select('genre');
            $this->ebook = new Zend_Form_Element_Checkbox('ebook');

            // ... и еще разные элементы

            // теперь подумаем про валидацию
            // для isbn воспользуемся встроенным
            $this->isbn->addValidator(new Zend_Validate_Isbn());
            // год издания должен быть не больше текущего и являтся целым числом
            $this->year->addValidator(new Zend_Validate_LessThan(date('Y')));
            $this->year->addValidator(new Zend_Validate_Int());
            // жанр должен входить в список известных нам жанров
            $this->genre->addValidator(new Zend_Validate_InArray(array('haystack'=>array(/** ? */))));

            // ... и т.д. еще много валидаторов
        }
    }

**BookController**

В контроллере, по идеи, никаких заморочек не должно быть. Все стандартно - приняли запрос, отправили в форму, если форма не валидна - показали пользователю ошибки. Если же форма валидна, то по всем заповедям православно-тонкого контроллера, передаем запрос в некий специализированный сервис Service_BookSearch, который будет выполнять поиск.

    // application/controllers/BookController.php
    class BookController extends Zend_Controller_Action
    {
        // .. некоторое экшены

        public function searchAction()
        {
            $form = new Form_BookSearch();
            $this->view->form = $form;
            $this->view->results = ArrayCollection();

            // недопустимый запрос
            if (!$this->_request->isGet()) {
                throw new Zend_Controller_Exception('GET request only');
            }

            // невалиданая форма
            if (!$form->isValid($this->_getAllParams())) {
                return;
            }

            // поисковый механизм
            $searchService = new Service_BookSearch();
            $this->view->results = $searchService->findAll($form->getValues());
        }

        // .. другие экшены
    }

На самом деле, сразу предупреждаю, - на практике контроллер почти никогда не получается таким простым (этот у нас явно сферический и в вакууме). Обычно на него подвязывается еще куча неспециализированного функционала по отношению к поиску, например ведение логов (аналитики) запросов, подсчет статистики попадания элементов в результаты поиска, пейджеры, навигация и т.д.

**BookSearchService**

С этой частью рассказа в Zend-е всегда сложно :) Стандартной реализации модели нет, поэтому полный простор для творчества. Я здесь не буду растекаться мыслью по древу и тянуться ко всяким модным паттернам реализации персист-независимой реализации модели. Опишу суть того, что нам нужно получить на выходе.

    // application/services/BookSearch.php
    class Service_BookSearch
    {
        // ... функции

        public function findAll($params = array())
        {
            $table = new Zend_Db_Table('books');
            $select = $table->select();

            if (array_key_exists('isbn', $params)) {
                $select->where('isbn = ?', $params['isbn']);
            }

            if (array_key_exists('title', $params)) {
                $select->where("title LIKE %{$params['title']}"); // никогда так не делайте (!)
            }

            if (array_key_exists('year', $params)) {
                $select->where('year >= ?', $params['year']);
            }

            // ... и еще большая куча IF, большинство из которых будет намного сложнее -
            // особенно если вспомнить, что некоторые наши критерии берутся из другого домена,
            // хранятся в другой таблице... и вообще обладают большим количеством собственных правил поведения

            // и здесь будет некая магия обработки коллекции сущностей,
            // которая нас сейчас не сильно волнует
            return Model_Book_CollectionFactory::fromRowset($table->fetchAll($select));
        }

        // ... тоже функции
    }

В принципе, все это в совокупности в итоге таки будет работать. Но... С какими проблемами мы столкнемся на практике
- длинное полотно кода формы и сервиса
- валидация данных на уровне сервиса (положиться только на форму нельзя - это твердо свяжет поисковый запрос с формой и не позволит безопасно использовать его внутри приложения), что приведет к дублированию кода валидации
- большое количество зависимостей в случае сложных критериев (например, хранение данных в нескольких таблицах)
- отсутствие какой-либо гибкости - а что если завтра придется подключить в эту схему Sphinx или другой поисковый движек
- непрозрачность интерфейса функции findAll() - мы не узнаем какие могут быть $params, если явно не залезем в код сервиса
- и т.д.

Проблемы можно еще долго перечислять, давайте лучше перейдем к их решению.

### 3. "Любой термин доменной области должен быть выражен явно" и другие DDD практики

Для решения описанных выше проблем воспользуемся некоторыми принципами и паттернами DDD.

_Извлечение скрытого понятия_ - подразумевает, что любой термин из предметной области, используемый в приложении, должен быть выражен в приложении **явно**. Возьмем к примеру тот же ISBN. В форме поиска мы создали поле с таким именем и привесили на него некий валидатор, в сервисе, который формирует поисковый запрос мы сделали проверку на валидность этого ISBN, и вложили в SQL запрос column-параметр с таким именем. Т.е. понятие ISBN прошло через весь цикл выполнения, но не было представлено каким-то отдельным объектом. Это означает, что все наши _знания_ об этом понятии "расползлись" по коду формы, сервиса, запроса и даже структуры базы данных. Почему на пришлось дублировать код валидации на двух уровнях? - Потому что нет объекта, отвечающего за инкапсулирования знания о ISBN, который и должен был бы взять на себя ответственность за валидацию. Поэтому первым нашим шагом будет явное выражение понятия, в данном случае через создания фильтра IsbnFilter (по сути дела, правильнее было бы сделать специальный value object и выполнять валидацию в момент его создания, но это только усложнило бы код и увело нас в сторону от основной темы).

_Спецификация_ - паттерн, позволяющий явно (см. предыдущий пункт) описать совокупность некоторых требований к объекту.

    Реализация правил прикладной модели (деловых регламентов) часто не вписывается в обязанности никаких из лежащих на поверхности сущностей (entity) или объектов-значений (value object), а их разнообразие и обилие возможных комбинаций может исказить основной смысл объекта предметной области... Спецификация - это предикат, который определяет, удовлетворяет объект некоторым критериям или нет.

Следуя принципу единой ответственности класса, в случае многокритериального отбора, мы должны будем создать для каждого критерия, имеющего прямое отображение в предметной области, свой собственный спецификатор. Например, ISBN спецификатор может проверять имеет ли конкретная сущность Book указанный ISBN код, а спецификатор PriceRange[min,max] будет проверяет лежит ли цена на кницу в пределах от min до max. И т.д. Как правильно связать эти спецификации в единый многокритериальный запрос?

_Composite pattern_ - структурный шаблон проектирования, объединяет объекты в древовидную структуру предоставляя возможность использования единого интерфейса как для работы с иерархиями объектов, так и с листовыми объектами. Подробнее можно почитать на [Wikipedia](http://en.wikipedia.org/wiki/Composite_pattern). Этот паттерн является классическим и в DDD занимает важное место, выступая одним из основных механизмов следования принципу _Замкнутости операций_ (Closure of Operations). Основная идея: дать возможность пользователю объединять фильтры в некоторую цепочку (FilterChain), к которой можно прикреплять другие фильтры (appendFilter) или другие цепочки фильтров, и которая будет вести себя так, как будто представлять собой обычный фильтр (единый API). В итоге конечному пользователю (контроллеру, сервису, форме и т.д.) будет неважно с чем он работает - с фильтром или с их цепочкой.

### 4. Сбор фильтров в формах и контроллерах

### 5. Использование фильтров на уровне репозитория

Начну с этого, потому что это, вроде как, самая важная часть решаемой нами задачи. И так, контроллер передал в сервис filter, инкапсулирующий в себе всю информацию о запросе пользователя. Предположим пока для простоты, что репозиторий работает у нас с некоторой таблицей books в MySQL. Это значит, что теперь

### 6. Использование фильтров на уровне коллекции

Если бы мы реализовывали свои приложения на 100% следуюя принципам DDD, то последнии два пункта были бы неразделимы. Согласно DDD-идеологии, репозиторий представляет из себя глобальную коллекцию, т.е. поиск по репозиторию должен представлять из себя ту же самую операцию, что и фильтрации отдельных элементов из коллекции. Технически, для нас это означало бы необходимость достать из базы данных все записи и отфильтровать их по фильтру. Но у нас есть несколько причин не делать этого :)

Я специально размести поиск по репозиторию раньше, чем выборку из коллекции, потому что эта операция более "привычна" для большинства проектов. Коллекции сами по себе встречаются в архитектурах реже. Я видел очень много серьезных по размеру разработок, которые передают коллекции обычными массивами. Но это отдельная длинная история. Сейчас я просто хочу обратить ваше внимание на то, что созданные нами фильтры удобно использовать в коллекциях.

Предположим вы сделали описанный выше поиск, и product owner попросил возле результатов поиска показать виджет с теми книгами из результатов, которые пользователь уже раньше просматривал. В этом случае удобно было бы воспользоваться аналогичным домен-фильтром для фильтрации уже существующей коллекции.

    // ... some actions
    $books = $bookRepository->findByFilter($searchCriteria);
    $viewedBooks = $books->filter(new Filter\Viewer($this->getCurrentUser()));
    // ... some other actions

Внутренняя реализации подобной фильтрации коллекции обычно проще, чем Builder запросов на персист-хранилище. Самый легкий варинт - воспользоваться идее DDD спецификаций и реализовать в фильтре функцию `isSatisfiedBy()`.

    // models/Domain/Book/Filter/Specification.php
    namespace Domain\Book\Filter;

    interface Specification
    {
        public function isSatisfiedBy(\Book\Book $entity);
    }

    // models/Domain/Book/Filter/Isbn.php
    namespace Domain\Book\Filter;
    use Book;

    class Isbn implements Specification
    {
        protected $_isbn = '';

        public function __construct($isbn) {
            $this->_isbn = $isbn;
        }

        // Check if book entity has the same ISBN code as we setted throught constructor
        public isSatisfiedBy(Book $entity) {
            return ($this->_isbn === $entity->getIsbn());
        }
    }

Нам также удобно будет немного допилить FilterChain, что он также поддерживал возможности специфицирования объектов. В коде это будет выглядить приблизительно так:

    namespace Domain\Book\Filter;

    use Domain\Book;

    class FilterChain implements Filter, Specification
    {
        // ... some functions

        public function isSatisfiedBy(Book $entity) {
            foreach($this->getFilters() as $specification) {
                // If one of filter in chain does not support specification,
                // we should throw runtime exception
                if (!$filter instanceof Specification) {
                    throw new RuntimeException('Current filter chain does not support specification mechanism');
                }

                if (!$specification->isSatisfiedBy($entity)) {
                    return false;
                }
            }

            return true;
        }

        // ... some other functions
    }

В таком случае, очень просто организовать итерацию по элементам коллекции, отбирая нужные нам элементы в отдельную саб-коллекцию. В упрощенном виде это будет выглядеть так:

    namespace Domain\Book;

    class BookCollection
    {
        // ... some functions

        /**
         * @param  Filter\Specification $specification Can be single filter or even filter chain
         * @return BookCollection
         */
        public function filter(Filter\Specification $specification)
        {
            $subCollection = new BookCollection();
            forech($this->getItems() as $book) {
                if ($specification->isSatisfiedBy($book)) {
                    $subCollection->add($book);
                }
            }

            return $subCollection;
        }

        // ... some other functions
    }

### 7. Вопросы?

P.S. Код приведен AS IS и не претендует на абсолютную архитектурную и идеологическую (или любую другую) граммотность. Мнение читателя может расходится с мнение автора, равно как и опыт и подходы к использованию различных паттернов проектирования.

{% endblock %}

