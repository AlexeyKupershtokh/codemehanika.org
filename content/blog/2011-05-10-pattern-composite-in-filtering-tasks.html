{% extends '_post.html' %}

{% hyde
    title: DDD подход к решению задачи сложной фильтрации данных
    created: 2011-06-01
    published: False
    categories: Архитектура, Практика DDD
    display_in_list: False
    snip: "Эта заметка представляет из себя некую выборку идей и подходов к организации сложной фильтрации и кастомизированного поиска, которые я использую в своем проекте. Пишу по многочисленным просьбам (здесь и здесь). Все подходы описаны на конкретном примере, очень распространенном в практике создания веб-приложений. Приведенный код в большинстве своем является условным и чисто-показательным, но частично изъят из боевых окружения."
%}

{% block article %}
### 1. Постановка задачи

Давайте рассмотрим типичную ситуацию на типичном веб-проекте: социальная сеть для любителей литературы предоставляет своим пользователям удобный расширенный поиск, содержащий такие поля, как:
- ISBN
- название (точное или по частичному совпадению)
- автор произведения
- издатель
- год издания (переиздания)
- язык (основной и переводы)
- жанр
- тематическая категория (или теги)
- электронная версия (да/нет)
- рейтинг по оценкам других пользователей
- популярность по пользовательским просмотрам (или комментариям)
- ... другие критерии

С какими техническими здаачами вам придется столкнуться для реализации данного функционала:
- создать форму с большим количество UI элементов под каждый из критериев (вопрос удобства и юзабельности мы сейчас не рассматриваем)
- принять запрос на поиск от пользователя в виде GET (POST?) запроса (get очевидно удобнее для открытых поисковых систем)
- провалидировать каждый из этих поисковых критериев
- в случае валидности запроса передать список этих критериев на уровень ниже и выбрать данные из БД
- в случае невалидности запроса показать пользователю список ошибок
- отрендерить форму с конкретными значениями по каждому критерию
- показать результат поиска (эта задача технически существует, но мы пока рассматриваем только вышестоящие)

В принципе, этот список с некоторомыми поправками будет актуален для любой обработки запросов пользователей, сформированных с веб-формы. Ничего необычного в этих задачах нет. Вопрос в том, что каждый из отдельных критериев полученных в запросе требует отдельной, зачастую специфичной, обработки - это приводит к тому, что количество кода растет очень быстро. И если не использовать какую-нибудь логичную систему организации этого кода, то постепенно будет получатся лапша, которую сложно сопровождать и дополнять.

Сейчас мы попробуем сформировать именно такую систему. Какие цели будут стоять перед нами:
- снизить до нуля дублирование кода
- максимально приблизится к SOLID, разбивая код на небольшие и абсолютно прозрачные куски функционала
- добится реюзабельности написанного кода в других частях приложения (и даже в других приложениях)
- обеспечить максимальную простоту добавления новых критериев, а также внесение изменений в обработку существующих
- полностью абстрагироваться от персистеного хранилища (БД и др.), так чтобы мы имели возможность менять схему храния данных с минимальными изменениям в коде

Небольшой комментарий к последнему пункту. Здесь имеется ввиду не только возможность быстро сменить базу данных с MySQL на какое-нибудь noSQL решение. Здесь мы говорим о простой возможности реализовать и менять хранение данных: от мелкой смены названия колонок в таблицах базы данных, до вынесения поисковой логики на Sphinx или другой поисковый демон.

### 2. Классическая схема решения

### 3. Любой термин доменной области должен быть выражен явно

### 4. Сбор фильтров в формах и контроллерах

### 5. Использование фильтров на уровне коллекции

### 6. Использование фильтров на уровне репозитория

{% endblock %}

