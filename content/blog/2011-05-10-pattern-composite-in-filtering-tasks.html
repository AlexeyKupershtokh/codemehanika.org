{% extends '_post.html' %}

{% hyde
    title: DDD подход к решению задачи сложной фильтрации данных
    created: 2011-06-01
    published: False
    categories: Архитектура, Практика DDD
    display_in_list: False
    snip: "Эта заметка представляет из себя некую выборку идей и подходов к организации сложной фильтрации и кастомизированного поиска, которые я использую в своем проекте. Пишу по многочисленным просьбам (здесь и здесь). Все подходы описаны на конкретном примере, очень распространенном в практике создания веб-приложений. Приведенный код в большинстве своем является условным и чисто-показательным, но частично изъят из боевых окружения."
%}

{% block article %}
### 1. Постановка задачи

Давайте рассмотрим типичную ситуацию на типичном веб-проекте: социальная сеть для любителей литературы предоставляет своим пользователям удобный расширенный поиск, содержащий такие поля, как:
- ISBN
- название (точное или по частичному совпадению)
- автор произведения
- издатель
- год издания (переиздания)
- язык (основной и переводы)
- жанр
- тематическая категория (или теги)
- электронная версия (да/нет)
- рейтинг по оценкам других пользователей
- популярность по пользовательским просмотрам (или комментариям)
- ... другие критерии

С какими техническими здаачами вам придется столкнуться для реализации данного функционала:
- создать форму с большим количество UI элементов под каждый из критериев (вопрос удобства и юзабельности мы сейчас не рассматриваем)
- принять запрос на поиск от пользователя в виде GET (POST?) запроса (get очевидно удобнее для открытых поисковых систем)
- провалидировать каждый из этих поисковых критериев
- в случае валидности запроса передать список этих критериев на уровень ниже и выбрать данные из БД
- в случае невалидности запроса показать пользователю список ошибок
- отрендерить форму с конкретными значениями по каждому критерию
- показать результат поиска (эта задача технически существует, но мы пока рассматриваем только вышестоящие)

В принципе, этот список с некоторомыми поправками будет актуален для любой обработки запросов пользователей, сформированных с веб-формы. Ничего необычного в этих задачах нет. Вопрос в том, что каждый из отдельных критериев полученных в запросе требует отдельной, зачастую специфичной, обработки - это приводит к тому, что количество кода растет очень быстро. И если не использовать какую-нибудь логичную систему организации этого кода, то постепенно будет получатся лапша, которую сложно сопровождать и дополнять.

Сейчас мы попробуем сформировать именно такую систему. Какие цели будут стоять перед нами:
- снизить до нуля дублирование кода
- максимально приблизится к SOLID, разбивая код на небольшие и абсолютно прозрачные куски функционала
- добится реюзабельности написанного кода в других частях приложения (и даже в других приложениях)
- обеспечить максимальную простоту добавления новых критериев, а также внесение изменений в обработку существующих
- полностью абстрагироваться от персистеного хранилища (БД и др.), так чтобы мы имели возможность менять схему храния данных с минимальными изменениям в коде

Небольшой комментарий к последнему пункту. Здесь имеется ввиду не только возможность быстро сменить базу данных с MySQL на какое-нибудь noSQL решение. Здесь мы говорим о простой возможности реализовать и менять хранение данных: от мелкой смены названия колонок в таблицах базы данных, до вынесения поисковой логики на Sphinx или другой поисковый демон.

Давайте теперь проанализируем классический подход к решению таких задач (в рамках zf application) и посмотрим на те проблемы, которые в этом случае возникают.

### 2. Классическая схема решения

# Zend_Form

# SearchController

# Zend_Table_Select

### 3. Любой термин доменной области должен быть выражен явно

### 4. Сбор фильтров в формах и контроллерах

### 5. Использование фильтров на уровне репозитория

Начну с этого, потому что это, вроде как, самая важная часть решаемой нами задачи. И так, контроллер передал в сервис filter, инкапсулирующий в себе всю информацию о запросе пользователя. Предположим пока для простоты, что репозиторий работает у нас с некоторой таблицей books в MySQL. Это значит, что теперь

### 6. Использование фильтров на уровне коллекции

Если бы мы реализовывали свои приложения на 100% следуюя принципам DDD, то последнии два пункта были бы неразделимы. Согласно DDD-идеологии, репозиторий представляет из себя глобальную коллекцию, т.е. поиск по репозиторию должен представлять из себя ту же самую операцию, что и фильтрации отдельных элементов из коллекции. Технически, для нас это означало бы необходимость достать из базы данных все записи и отфильтровать их по фильтру. Но у нас есть несколько причин не делать этого :)

Я специально размести поиск по репозиторию раньше, чем выборку из коллекции, потому что эта операция более "привычна" для большинства проектов. Коллекции сами по себе встречаются в архитектурах реже. Я видел очень много серьезных по размеру разработок, которые передают коллекции обычными массивами. Но это отдельная длинная история. Сейчас я просто хочу обратить ваше внимание на то, что созданные нами фильтры удобно использовать в коллекциях.

Предположим вы сделали описанный выше поиск, и product owner попросил возле результатов поиска показать виджет с теми книгами из результатов, которые пользователь уже раньше просматривал. В этом случае удобно было бы воспользоваться аналогичным домен-фильтром для фильтрации уже существующей коллекции.

    // ... some actions
    $books = $bookRepository->findByFilter($searchCriteria);
    $viewedBooks = $books->filter(new Filter\Viewer($this->getCurrentUser()));
    // ... some other actions

Внутренняя реализации подобной фильтрации коллекции обычно проще, чем Builder запросов на персист-хранилище. Самый легкий варинт - воспользоваться идее DDD спецификаций и реализовать в фильтре функцию `isSatisfiedBy()`.

    // models/Domain/Book/Filter/Specification.php
    namespace Domain\Book\Filter;

    interface Specification
    {
        public function isSatisfiedBy(\Book\Book $entity);
    }

    // models/Domain/Book/Filter/Isbn.php
    namespace Domain\Book\Filter;
    use Book;

    class Isbn implements Specification
    {
        protected $_isbn = '';

        public function __construct($isbn) {
            $this->_isbn = $isbn;
        }

        // Check if book entity has the same ISBN code as we setted throught constructor
        public isSatisfiedBy(Book $entity) {
            return ($this->_isbn === $entity->getIsbn());
        }
    }

Нам также удобно будет немного допилить FilterChain, что он также поддерживал возможности специрования объектов. В коде это будет выглядить приблизительно так:

    namespace Domain\Book\Filter;

    use Domain\Book;

    class FilterChain implements Filter, Specification
    {
        // ... some functions

        public function isSatisfiedBy(Book $entity) {
            foreach($this->getFilters() as $specification) {
                // If one of filter in chain does not support specification,
                // we should throw runtime exception
                if (!$filter instanceof Specification) {
                    throw new RuntimeException('Current filter chain does not support specification mechanism');
                }

                if (!$specification->isSatisfiedBy($entity)) {
                    return false;
                }
            }

            return true;
        }

        // ... some other functions
    }

В таком случае, очень просто организовать итерацию по элементам коллекции, отбирая нужные нам элементы в отдельную саб-коллекцию. В упрощенном виде это будет выглядеть так:

    namespace Domain\Book;

    class BookCollection
    {
        // ... some functions

        /**
         * @param  Filter\Specification $specification Can be single filter or even filter chain
         * @return BookCollection
         */
        public function filter(Filter\Specification $specification)
        {
            $subCollection = new BookCollection();
            forech($this->getItems() as $book) {
                if ($specification->isSatisfiedBy($book)) {
                    $subCollection->add($book);
                }
            }

            return $subCollection;
        }

        // ... some other functions
    }

{% endblock %}

