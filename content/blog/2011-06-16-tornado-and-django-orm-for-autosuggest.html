{% extends '_post.html' %}

{% hyde
    title: "Tornado, Django ORM и supervisord для моментальной отдачи autosuggest"
    created: 2011-06-16
    published: True
    categories: Инфраструктура, Производительность, Python, Django, Tornado
    display_in_list: True
    snip: О том, почему критично важно экономить ресурсы на таких процессах как ajax response для autosuggest поля, я уже писал (и рассказывал). На конференции в Питере, я предложил вариант phpDaemon для демонизации zf приложения. Сегодня напишу об еще одном варианте - Tornado + Django ORM. Для тех, кто уверен, что асинхронные сервера это сложно, скажу заранее - обойдемся 20ю строками кода.
%}

{% block article %}
### 1. Формулировка задачи

Не буду далеко ходить в лес, и вернусь к одной из задач, которая была поставлена в демонстрационном приложении на Питерскую конференцию - отображение autosuggest в поле поиска по тегам. [Слайды](http://codemehanika.org/blog/2011-05-14-zf-phpdaemon-varnish-esi.html) (см. 27й слайд) и [код приложения](https://github.com/kachayev/zfconf-speech).

С технической точки зрения, у нас есть таблица `speech_tag` в MySQL базе с полями speech_id и text. С фронтенд обработчика мы получаем запрос вида

    /tag/suggest/?q=(введенная пользователем строка)

и должны в ответ вернуть JSON объект формата

    [{ value: тег1 }, { value: тег2 },]

где все теги удовлетворяеют запросу `LIKE %(введенная пользователем строка)%`. Достаточно банальная и распространненая задача, поэтому, чтобы было не скучно, мы решили поставить дополнительное условие - максимально быстро, масштабируемо, с использованием минимума ресурсов сервера и способностью выдерживать большое количество одновременно-ищущих пользователей,

В этот раз, я представлю схему решения этой задачи на языке Python, с использование Tornado server (асинхронный сервер, который будет принимать и роутить запросы) и Django ORM (мощный ORM, который даст нам возможность не ковырятся низкоуровнево с базой данных). По старой традиции, выложил код данного вариант в отдельном git branch - [tornado](https://github.com/kachayev/zfconf-speech/tree/tornado).

### 2. Подготовка инфраструктуры

**Python**

Собственно, на этом языке программирования мы будем писать функционал. Как установить Python можно почитать в [официальной доке](http://www.python.org/getit/) или в том же [Dive Into Python](http://diveintopython.org/installing_python/index.html#install.choosing). Нам понадобится версия из ветки 2.x, желательно 2.7.x. Проверить, что все установилось без проблем можно вызовом интерактивной консоли командой

    $ python
    Python 2.7.1+ (r271:86832, Apr 11 2011, 18:13:53)
    [GCC 4.5.2] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>>


**Tornado**

Для решения задачи мы возьмем асинхронный сервер на Python - [Tornado](http://www.tornadoweb.org/). Почему именно этот? Ну, во-первых, он очень простой (на порядок проще того же Twisted). А, во-вторых, результаты [нагрузочных тестов](http://nichol.as/asynchronous-servers-in-python) красноречиво говорят сами за себя. Установить Tornado не сложно:

    wget http://github.com/downloads/facebook/tornado/tornado-1.2.1.tar.gz
    tar xvzf tornado-1.2.1.tar.gz
    cd tornado-1.2.1
    python setup.py build
    sudo python setup.py install


Для нормальной работы tornado сервера нам также могут понадобится некоторые библиотеки, типа pycurl. О том как их устанавливать на различных платформах читаем в [официальной документации](http://www.tornadoweb.org/documentation#download-and-install).

**Django**

Из Django нам понадобится только ORM. Но установить все равно придется весь фреймворк. Для инсталляции Django существует очень много способов, в зависимости от платформы и ваших личных предпочтений. Обо всех можно узнать в [документации](https://docs.djangoproject.com/en/1.3/intro/install/). Проверить успешность установки можно в интерактивном сеансе Python:

    $ python
    Python 2.7.1+ (r271:86832, Apr 11 2011, 18:13:53)
    [GCC 4.5.2] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import django
    >>> print django.get_version()
    1.3

Если Django был установлен не корректно, то после команды `import django` вы поймаете exception.
Поскольку мы будем работать с MySQL базой данных, нужно установить библиотеку для работы с этой базой данных. Проще всего через easy_install или pip:

    pip install MySQL-python

**Supervisor**

Чтобы добится стабильной работы нашего сервера, процесс нужно демонизировать. Удобнее всего это сделать с помощью утилиты [Supervisor](http://supervisord.org/). Которая, кстати, тоже написана на python. Если раньше не сталкивались с этим проектом, то соверую обратить внимание, так как вещь действительно полезная. Суть работы supervisor-a - это, так называемая, внешняя демонизация. Мы указываем команду, которую необходимо выполнить, а демон supervisord запускает ее в фоновом режиме, переопределяя файлы STDOUT, STDERR, а также выполняя перезапуск команды в случае остановки выполнения (либо по нашему требованию).

Установка выполняется через easy_install

    easy_install supervisor

Примеры конфигурационных файлов, а также use cases можно найти в официальной документации.

**Nginx**

Скорее всего, эта штука у вас уже есть. Nginx как и раньше будет выполнять у нас роль "военачальника" и висеть на фронтенде, распределяя запросы по backend обработчикам. В ветке `tornado` я добавил в конфигурацию nginx-а один дополнительный редирект:

	  location ^~ /suggest {
		  proxy_pass http://localhost:8888/suggest;
	  }

Посмотреть на [github](https://github.com/kachayev/zfconf-speech/blob/tornado/infrastructure/nginx/zfconf#L23
). Соответственно, в файле [/public/js/interface.js](https://github.com/kachayev/zfconf-speech/blob/tornado/public/js/interface.js#L11) поменялся `serviceUrl` параметр.


### 3. Код сервера

Давайте теперь напишем кода нашего сервера. Как я и говорил выше, нам понадобится только один небольшой файл - suggest.py - код можно посмотреть в ветке [tornado на github](https://github.com/kachayev/zfconf-speech/blob/tornado/suggest.py) или ниже с подробными комментариями всего происходящего.

    # Импортируем необходимые для работы tornado
    import sys, os
    import tornado.httpserver, tornado.ioloop, tornado.web
    from  tornado.escape import json_encode

    # Django settings
    # Весь файл настроек нам не нужен сейчас, сейчас понядобятся только настройки базы данных,
    # поэтому именно их мы и передаем в метод configure: name, user, password (укажите свои)
    # Пустые строки в качестве параметров DATABASE_HOST и DATABASE_PORT означают использование
    # дефолтных (localhost и 3306 соответственно). При необходимости - подставьте свои.
    from django.conf import settings
    settings.configure(DATABASE_ENGINE='mysql', DATABASE_NAME='zfconf',
                       DATABASE_USER='root', DATABASE_PASSWORD='kachayev',
                       DATABASE_HOST = '', DATABASE_PORT = '')

    # Создаем класс Django модели для работы с таблицей speech_tag
    from django.db import models
    class Tag(models.Model):
        """
        Define model Tag for switching from database LIKE tags
        """

        # Описание полей таблицы, speech_id нам по факту не пригодится
        speech_id = models.IntegerField()
        text = models.CharField(max_length=50)

        # Meta данные для нормальной работы ORM,
        # сюда же можно добавить дефолтную сортировку и другие настройки
        class Meta:
            app_label = 'speech'
            db_table = 'speech_tag'

        # Текстовое представление для класса модели
        def __unicode__(self):
            return self.text

    # Класс обработчика запроса
    # Наследник класса tornado.web.RequestHandler
    class TagsSuggestHandler(tornado.web.RequestHandler):
        """
        Handler for GET HTTP request for tags suggestion
        """
        # Обрабатываем GET запросы
        def get(self):
            # Достаем из запроса q параметр (запрос выглядит /suggest?q=tag)
            # Значение параметра будет отдано как list, поэтому мы сразу достаем 0й элемент
            # По факту, мы могли бы сделать эту процедуру более защищенной
            # и бросать ошибку в случае отсутствующего или пустого q параметра,
            # а также в случае получения запроса вида /suggest?q[]=tag1&q[]=tag2
            query = self.request.arguments.get('q', [''])[0]

            # Сообщаем браузеру о том, что это вовсе не HTML, а JSON
            self.set_header("Content-Type", "application/json")

            # В следующей строчке состредоточена большая часть написанной нами логики
            # Генератор списка, в будущем переданный в json_encode, делает следующее:
            # 1. получает теги из таблицы speech_tag запросом LIKE
            # (переданный менеджеру фильтр text__icontains)
            # 2. для каждого объекта Tag добавляем новый item вида {value: tag.text}
            tags = [{'value': tag.text} for tag in Tag.objects.filter(text__icontains=query)]

            # json_encode кодирует list в JSON формат, а метод write добавляет контент в response
            self.write(json_encode(tags))

    # Создаем объект Web Application, определяеющий правила роутинга хендлеров
    # с одним единственным правилом: /suggest* запрос будет обработан хендлером TagsSuggestHandler
    application = tornado.web.Application({
        (r'/suggest', TagsSuggestHandler),
    })

    if __name__ == '__main__':
        # Создаем объект сервера, передавая в констркутор HTTPServer объект Web Application
        http_server = tornado.httpserver.HTTPServer(application)
        # Биндим сервер к 8888 порту (можете использовать любой другой свободный)
        http_server.listen(8888)
        # Запускаем основной Loop
        tornado.ioloop.IOLoop.instance().start()


### 4. Запуск сервера

Для того, чтобы запустить сервер, нам достаточно в консоли перейти в директорию проекта и выполнить команду

    python suggest.py

С этого момента, запрос на localhost:8888/suggest должен вернуть вам JSON ответ. Проверить это можно, например, с помощью утилиты wget. А можно и на реальном приложении - если вы правильно настроили nginx, то autosuggest поле на главной странице проекта zfconf-speech должно работать нормально.

Поскольку консоль осталась для сервера STDOUT, то здесь вы можете увидеть также трассировки возникающих exceptions, и коды ошибок работы сервера (404, 500 etc), которые автоматически будут обработаны на уровне внутренней реализации Tornado.

Займемся демонизацией. Конфигурационный файл для supervisor может выглядеть приблизительно так:

    [program:suggest]
    command=python /path/to/project/suggest.py
    priority=10
    autorestart=true # перезапускать при падении
    autostart=true # запускать при старте supervisord
    startsecs=1
    startretries=3
    stopsignal=QUIT # сигнал, который будет отправлен процессу для завершения работы
    stopwaitsecs=10
    redirect_stderr=true
    stdout_logfile=/var/log/suggest.log
    stdout_logfile_maxbytes=10MB

Большинство параметром понятно по названию. Для других даны небольшие комментарии. При использовании нескольких процессов (worker-ов) нужно использовать специальный параметр numprocs, почитать о нем можно [в доке](http://supervisord.org/configuration.html#program-x-section-values). Далее, перегружаем конфигурации:

    $ sudo supervisorctl reload all

И убеждаемся по выводу

    $ sudo supervisorctl status

что процесс `suggest` получил статут `RUNNING`. Это значит, что наш сервер запущен, успешно функционирует и будет перезапущен при любом непредвиденном отключении.

### 5. Тесты и подведение итогов

Теперь пришлом время оправдать слово **"моментальный"** в заголовке статьи. Я мог бы здесь приводить результаты тестов, но не буду - это не очень-то репрезентативно. Например, у меня на ноутбуке siege на 5 одновременных подключениях (-с 5) отдает результат

    Availability:		           100.00 %
    ...
    Longest transaction:	        0.01
    Shortest transaction:	        0.00

Более точных результатов мы не получим, потому что 1/100 секунды минимальный тик измерения. Нужно ли нам подробнее? - Вряд ли, с учетом того, что это меньше географической задержки response time даже для не сильно далеких серверов. Советую вам самим поигратся с тестами (ab, siege & Co), обратив при этом внимание на:

- до некоторого количества одновременных подключений response time не увеличивается;
- на 200-300 одновременных подключениях появляется заметная разница между прямым обращением к порту 8888 и проксированием через nginx. Классический результат, в принципе, - скорость обработки на ~30% больше, но дисперсия результатов заметно ниже (разница и разброс между максимальным и минимальным временем). Это связано с тем, что у nginx есть своя неблокирующая очередь, что приводит к "сглаживанию" времени отдачи ответа;
- для тестирования на очень-очень большом количестве подключений (Nx1000+) придется повозится с настройками системы (сокетов, в частности), иначе просто не удастся провести тест. В ссылке на бенчмарки в начале статьи есть описание сей процедуры;

По факту, вы должны понимать, что горлышко у этой системы - MySQL и наш `LIKE %tag%` запрос. Дальнейшая оптимизация - кеширование, использование более быстрых хранилищь, search engine и precalculated indexes и т.д.

Главная цель этой статьи была не создать самую быструю систему autosuggest, а показать **способ создания processing обертки, который сводит практически к нулю затраты времени и ресурсов на этот самый процессинг** (прием запроса, роутинг, обработка ошибок, формирование коннекта к хранилищу, рендерниг результата). По сути, мы добивались того, чтобы время получения готового ответа ~ времени обработки запроса на хранилище данных. И можно уверено сказать, что этого мы добились.

P.S. Небольшая ремарка. По сути, Django ORM здесь не обязательна, и можно с ней не заморачиватся. В tornado есть "встроенный" клиент tornado.database, так что можно было просто писать SELECT запрос в ручную и разбирать ответ (примеры использования можно найти на гитхабе). Просто добавленная Django ORM дает нам огромные возможности по расширению этого примера на практически любые ситуации организации данных.

{% endblock %}

