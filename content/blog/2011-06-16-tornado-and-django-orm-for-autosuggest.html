{% extends '_post.html' %}

{% hyde
    title: "Tornado, Django ORM и supervisord для моментальной отдачи autosuggest"
    created: 2011-06-16
    published: False
    categories: Инфраструктура, Производительность, Python, Django, Tornado
    display_in_list: False
    snip: О том, почему критично важно экономить ресурсы на таких процессах как ajax response для autosuggest поля, я уже писал (и рассказывал). На конференции в Питере, я предложил вариант phpDaemon для демонизации zf приложения. Сегодня напишу о еще одном варианте: Tornado + Django ORM. Для тех, кто уверен, что асинхронные сервера это сложно, скажу заранее - обойдемся 20ю строками кода.
%}

{% block article %}
### 1. Формулировка задачи
### 2. Подготовка инфраструктуры

**Python**

Собственно, на этом языке программирования мы будем писать функционал. Как установить Python можно почитать в [официальной доке](http://www.python.org/getit/) или в том же [Dive Into Python](http://diveintopython.org/installing_python/index.html#install.choosing). Нам понадобится версия из ветки 2.*, желательно 2.7.*. Проверить, что все установилось без проблем можно вызовом интерактивной консоли командой

    $ python
    Python 2.7.1+ (r271:86832, Apr 11 2011, 18:13:53)
    [GCC 4.5.2] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>>


**Tornado**

Для решения задачи мы возьмем асинхронный сервер на Python - [Tornado](http://www.tornadoweb.org/). Почему именно этот? Ну, во-первых, он очень простой (на порядок проще того же Twisted). А, во-вторых, результаты [нагрузочных тестов](http://nichol.as/asynchronous-servers-in-python) красноречиво говорят сами за себя. Установить Tornado не сложно:

    wget http://github.com/downloads/facebook/tornado/tornado-1.2.1.tar.gz
    tar xvzf tornado-1.2.1.tar.gz
    cd tornado-1.2.1
    python setup.py build
    sudo python setup.py install


Для нормальной работы tornado сервера нам также могут понадобится некоторые библиотеки, типа pycurl. О том как их устанавливать на различных платформах читаем в [официальной документации](http://www.tornadoweb.org/documentation#download-and-install).

**Django**

Из Django нам понадобится только ORM. Но установить все равно придется весь фреймворк. Для инсталляции Django существует очень много способов, в зависимости от платформы и ваших личных предпочтений. Обо всех можно узнать в [документации](https://docs.djangoproject.com/en/1.3/intro/install/). Проверить успешность установки можно в интерактивном сеансе Python:

    $ python
    Python 2.7.1+ (r271:86832, Apr 11 2011, 18:13:53)
    [GCC 4.5.2] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import django
    >>> print django.get_version()
    1.3

Если Django был установлен не корректно, то после команды `import django` вы поймаете exception.
Поскольку мы будем работать с MySQL базой данных, нужно установить библиотеку для работы с этой базой данных. Проще всего через easy_install или pip:

    pip install MySQL-python

**Supervisor**

Чтобы добится стабильной работы нашего сервера, процесс нужно демонизировать. Удобнее всего это сделать с помощью утилиты [Supervisor](http://supervisord.org/). Которая, кстати, тоже написана на python. Если раньше не сталкивались с этим проектом, то соверую обратить внимание, так как вещь действительно полезная. Суть работы supervisor-a - это, так называемая, внешняя демонизация. Мы указываем команду, которую необходимо выполнить, а демон supervisord запускает ее в фоновом режиме, переопределяя файлы STDOUT, STDERR, а также выполняя перезапуск команды в случае остановки выполнения (либо по нашему требованию).

Установка выполняется через easy_install

    easy_install supervisor

Примеры конфигурационных файлов, а также use cases можно найти в официальной документации.

**Nginx**

Скорее всего, эта штука у вас уже есть. Nginx как и раньше будет выполнять у нас роль "военачальника" и висеть на фронтенде, распределяя запросы по backend обработчикам. В ветке `tornado` я добавил в конфигурацию nginx-а один дополнительный редирект:

	  location ^~ /suggest {
		  proxy_pass http://localhost:8888/suggest;
	  }

Посмотреть на [github](https://github.com/kachayev/zfconf-speech/blob/tornado/infrastructure/nginx/zfconf#L23
). Соответственно, в файле [/public/js/interface.js](https://github.com/kachayev/zfconf-speech/blob/tornado/public/js/interface.js#L11) поменялся `serviceUrl` параметр.


### 3. Код сервера

Давайте теперь напишем кода нашего сервера. Как я и говорил выше, нам понадобится только один небольшой файл - suggest.py - код можно посмотреть в ветке [tornado на github](https://github.com/kachayev/zfconf-speech/blob/tornado/suggest.py) или ниже с подробными комментариями всего происходящего.

    # Импортируем необходимые для работы tornado
    import sys, os
    import tornado.httpserver, tornado.ioloop, tornado.web
    from  tornado.escape import json_encode

    # Django settings
    # Весь файл настроек нам не нужен сейчас, сейчас понядобятся только настройки базы данных,
    # поэтому именно их мы и передаем в метод configure: name, user, password (укажите свои)
    # Пустые строки в качестве параметров DATABASE_HOST и DATABASE_PORT означают использование
    # дефолтных (localhost и 3306 соответственно). При необходимости - подставьте свои.
    from django.conf import settings
    settings.configure(DATABASE_ENGINE='mysql', DATABASE_NAME='zfconf',
                       DATABASE_USER='root', DATABASE_PASSWORD='kachayev',
                       DATABASE_HOST = '', DATABASE_PORT = '')

    # Создаем класс Django модели для работы с таблицей speech_tag
    from django.db import models
    class Tag(models.Model):
        """
        Define model Tag for switching from database LIKE tags
        """

        # Описание полей таблицы, speech_id нам по факту не пригодится
        speech_id = models.IntegerField()
        text = models.CharField(max_length=50)

        # Meta данные для нормальной работы ORM,
        # сюда же можно добавить дефолтную сортировку и другие настройки
        class Meta:
            app_label = 'speech'
            db_table = 'speech_tag'

        # Текстовое представление для класса модели
        def __unicode__(self):
            return self.text

    # Класс обработчика запроса
    # Наследник класса tornado.web.RequestHandler
    class TagsSuggestHandler(tornado.web.RequestHandler):
        """
        Handler for GET HTTP request for tags suggestion
        """
        # Обрабатываем GET запросы
        def get(self):
            # Достаем из запроса q параметр (запрос выглядит /suggest?q=tag)
            # Значение параметра будет отдано как list, поэтому мы сразу достаем 0й элемент
            # По факту, мы могли бы сделать эту процедуру более защищенной
            # и бросать ошибку в случае отсутствующего или пустого q параметра,
            # а также в случае получения запроса вида /suggest?q[]=tag1&q[]=tag2
            query = self.request.arguments.get('q', [''])[0]

            # Сообщаем браузеру о том, что это вовсе не HTML, а JSON
            self.set_header("Content-Type", "application/json")

            # В следующей строчке состредоточена большая часть написанной нами логики
            # json_encode кодирует list в JSON формат, а метод write добавляет контент в response
            # Генератор списка, переданный в json_encode делает следующее:
            # 1. получает теги из таблицы speech_tag запросом LIKE (переданный менеджеру фильтр text__icontains)
            # 2. для каждого объекта Tag добавляем в JSON новый item вида {value: tag.text}
            self.write(json_encode([{'value': tag.text} for tag in Tag.objects.filter(text__icontains=query)]))

    # Создаем объект Web Application, определяеющий правила роутинга хендлеров
    # с одним единственным правилом: /suggest* запрос будет обработан хендлером TagsSuggestHandler
    application = tornado.web.Application({
        (r'/suggest', TagsSuggestHandler),
    })

    if __name__ == '__main__':
        # Создаем объект сервера, передавая в констркутор HTTPServer объект Web Application
        http_server = tornado.httpserver.HTTPServer(application)
        # Биндим сервер к 8888 порту (можете использовать любой другой свободный)
        http_server.listen(8888)
        # Запускаем основной Loop
        tornado.ioloop.IOLoop.instance().start()


### 4. Запуск сервера

Для того, чтобы запустить сервер, нам достаточно в консоли перейти в директорию проекта и выполнить команду

    python suggest.py

С этого момента, запрос на localhost:8888/suggest должен вернуть вам JSON ответ. Проверить это можно, например, с помощью утилиты wget. А можно и на реальном приложении - если вы правильно настроили nginx, то autosuggest поле на главной странице проекта zfconf-speech должно работать нормально.

Поскольку консоль осталась для сервера STDOUT, то здесь вы можете увидеть также трассировки возникающих exceptions, и коды ошибок работы сервера (404, 500 etc), которые автоматически будут обработаны на уровне внутренней реализации Tornado.

Займемся демонизацией. Конфигурационный файл для supervisor может выглядеть приблизительно так:

    [program:suggest]
    command=python /path/to/project/suggest.py
    priority=10
    autorestart=true # перезапускать при падении
    autostart=true # запускать при старте supervisord
    startsecs=1
    startretries=3
    stopsignal=QUIT # сигнал, который будет отправлен процессу для завершения работы
    stopwaitsecs=10
    redirect_stderr=true
    stdout_logfile=/var/log/suggest.log
    stdout_logfile_maxbytes=10MB

Большинство параметром понятно по названию. Для других даны небольшие комментарии. При использовании нескольких процессов (worker-ов) нужно использовать специальный параметр numprocs, почитать о нем можно [в доке](http://supervisord.org/configuration.html#program-x-section-values). Далее, перегружаем конфигурации:

    $ sudo supervisorctl reload all

И убеждаемся по выводу

    $ sudo supervisorctl status

что процесс `suggest` получил статут `RUNNING`. Это значит, что наш сервер запущен, успешно функционирует и будет перезапущен при любом непредвиденном отключении.

### 5. Тесты и подведение итогов
{% endblock %}

