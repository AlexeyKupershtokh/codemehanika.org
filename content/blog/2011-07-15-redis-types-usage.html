{% extends '_post.html' %}

{% hyde
    title: Практические примеры "нестандартного" использования Redis для решения сложных задач
    created: 2011-07-15
    published: True
    categories: Инфраструктура, Производительность, Redis
    display_in_list: True
    snip: Redis не только супер быстрое key-value storage! (хотя этого у него не отберешь). Встроенные типы данных дают возможность решать с помощью Redis-а те задачи, с которыми очень трудно справиться при использоваии других хранилищ (а иногда и тех задач, которые классически выполняются совсем не хранилищами данных). В этой заметке описано несколько ситуаций из реальной практики разработки, когда Redis неожиданно становился просто-таки спасением
%}

{% block article %}
Вчера на 3й встрече "клуба" Zend_Coffee&Code я рассказывал немного о моделировании хранинения данных и много о возможностях key-value хранилища [Redis](http://redis.io/). К сожалению, получилось как обычно: времени мало, а  материала много. Поэтому рассмотрели, по сути, основы. Это важно, конечно. Но по результатам обсуждения (во время и после встречи) стало понятно: даже имея на руках информацию о том, что умеет Redis, сложно представить себе ситуации, в которых он оказывается просто незаменимым. Я рассказывал о практическом использовании Redis-а у себя в проекте, в этой заметке дополню этот рассказ еще несколькими чисто практическими обзорами.

### Генерирование уникального ID

Это простая задача. И Redis с ней справляется идеально. Чаще всего для обеспечения уникальности ID ресурсов мы используем автоинкрементные поля базы данных. Но нередко подобная роскошь нам недоступна. Как можно использовать Redis для получения Unique ID, например, для нового пользователя?

    redis> SET user:unique 1
    OK
    redis> INCR user:unique
    (integer) 2
    redis> INCR user:unique
    (integer) 3

Идея понятна? Время процессинга такого запроса на Redis-е не превышает 0.01-0.05 мс. Обратите внимание также на то, что операция INCR атомарна, а клиенту отдается инкрементированное значение. А это означает, что уникальность будет обеспечена даже в случае высокой конкурентности запросов (когда ключ инкрементируется огромным количеством клиентов одновременно).

### Рейтинг игроков и столь волнующий вопрос "На каком я месте?"

Представьте, что у нас есть многопользовательская игра "Морской бой". Каждому `игроку` за каждый убитый `корабль` добавляется количество `очков` по "разрядности" `корабля` (1-4). Для стимулирования интереса к проведению большего количества времени в нашей игре мы ведем общий рейтинг игроков. На какие вопросы должно уметь "отвечать" наше хранилище данных:

1. Какие 100 `игроков` имеют максимальное количество `очков`? (а первые 1000? а с 100 по 200 для пейджинга?)
2. На каком месте в рейтинге сейчас находится конкретный `игрок`?
3. Какие 100 `игроков` имеют максимальное количество `очков` за вчерашний день?

Скажу сразу, на все эти вопросы может ответить и MySQL. Реально может. В первом случае это `ORDER BY + LIMIT`, во втором - `COUNT(id) + WHERE score > ( SELECT score WHERE id = id )`. Но. Это все тяжелые и медленные запросы. Для третьего случая вообще решение получится нетривиальным. Прибавьте к этому проблемы с постоянными write операциями (при каждом убийстве корабля), особенно когда индекс по score будет большим.

Для изящного решения этой задачи на сумасшедших скоростях возьмем Redis и его sorted set. Назовем ключ `players:ranking`.

При регистрации новых пользователей добавляем их в sorted set с нулевым score:

    redis> ZADD players:ranking 0 "karandas"
    (integer) 1
    redis> ZADD players:ranking 0 "zar"
    (integer) 1
    redis> ZADD players:ranking 0 "djra"
    (integer) 1
    redis> ZADD players:ranking 0 "haron"
    (integer) 1

Если пользователь убил новый корабль, инкрементируем его счет на соответствующее количество очков:

    redis> ZADD players:ranking 0 "haron"
    (integer) 1
    redis> ZINCRBY players:ranking 1 "karandas"
    "1"
    redis> ZINCRBY players:ranking 2 "haron"
    "2"
    redis> ZINCRBY players:ranking 4 "djra"
    "4"
    redis> ZINCRBY players:ranking 1 "djra"
    "5"

(На самом деле отправлять запрос ZADD с нулевым score необязательно Инкремент score для несуществующего элемента в set-е следает это за нас.) Проверим, что "все на месте":

    redis> ZRANGE players:ranking 0 -1 WITHSCORES
    "zar"
    "0"
    "karandas"
    "1"
    "haron"
    "2"
    "djra"
    "5"

Ок. Трое наших "чемпионов":

    redis> ZREVRANGE players:ranking 0 2
    "djra"
    "haron"
    "karandas"

Нужен постраничный вывод? Пожалуйста:

    redis> ZCARD players:ranking
    (integer) 4
    redis> ZREVRANGE players:ranking 0 2
    ...
    redis> ZREVRANGE players:ranking 3 5
    ...

На какой позиции сейчас находится конкретный игрок?

    redis> ZREVRANK players:ranking "haron"
    (integer) 1
    redis> ZREVRANK players:ranking "djra"
    (integer) 0
    redis> ZREVRANK players:ranking "zar"
    (integer) 3

Давайте еще "вручим" медали всем, кто набрал больше score больше 1000. Проще простого:

    redis> ZREVRANGEBYSCORE players:ranking 9999999 2
    1) "djra"
    2) "haron"

Как решить вопрос с привязкой к дням? Для этого будем дублировать все операции INCR score игроков, и делает его как для ключа `players:ranking`, так и для ключа `players:ranking:day:<date>`. Таким образом, все продемонстрированные рейтинги мы сможем получить как "глобальные", так и для каждого конкретного дня.

Операции с sorted set-ами очень быстрые. Я много рассказывал о внутренней реализации сетов в Редисе и алгоритмической сложности различных операций с ними на встрече, сейчас повторятся не буду - вы всегда можете найти эту информацию в официальной документации.

### Операции, связанные с анализом временных промежутков

Эта ситуация демонстрирует а) как можно избавится от ненужных расчетов в приложении, пользуясь вроде как не для этого созданными фичами хранилища б) как можно "хитрить" со своими данными, ускоряя их обработку.

В общем, представьте себе задачу. У приложения есть `пользователи` (много), которые с мобильного устройства переодически отправляют на наш сервер информацию о своем местонахождении. Отправляют достаточно часто (скажем, 2-3 раза в минуту). Наша задача состоит в том, чтобы собирать из данных об отдельных `точках` в `маршруты`. При этом, если между двумя присланными на сервер `точками` прошло больше 300 секунд, то эти `точки` нужно поместить в разные `маршруты`.

Много пользователей + постоянный пул запросов на запись + слабая зависимость между добавляемыми данными = используем Redis. Пока все очевидно. Идем дальше.

Договоримся, что маршруты будем хранить по ключу вида `user:<userId>:route:<routeId>` в виде списка (LIST) `точек`. Элементами списка должны быть строки (STRING), поэтому будет хранить точку в виде сериализованного на клиенте словаря (dict для Python, array для PHP и т.д.) со значениями `lat`, `lng`, `time`. `userId` известен и определяется аутентификацией мобильного устройства, `routeId` генерируется уникальный для каждого нового `маршрута`.

Пока все просто. Работа с `точками` в `маршрутах` будет выглядеть так:

    redis> RPUSH user:100:route:usa50 "7;8;25" ## Добавляем новые точки "справа"
    redis> RPUSH user:100:route:usa50 "7;9.5;29"
    redis> RPUSH user:100:route:usa50 "7.3;9.5;32"
    redis> LLEN user:100:route:usa50  ## Получить длину маршрута
    redis> LRANGE user:100:route:usa50 0 -1  ## Все точки маршрута
    redis> LINDEX user:100:route:usa50 -1  ## Последняя точка в маршруте


Стандартно. И фокус не в этом. Гораздо интереснее процесс определения на клиенте: в какой маршрут мы должны добавить точку? Фактически это два вопроса: какой маршрут текущий + должны ли мы добавить полученную `точку` в текущий `маршрут` или все-таки создать новый?

Решение "в лоб" заключается в следующем: по специальному ключу `user:<userId>:current:route` будем хранить `<routeId>` текущего маршрута. А далее:

1. при получении новой точки, смотрим текущий маршрут
2. достаем из этого маршрута последнюю точку
3. десериализируем, вычисляем разницу по времени
4. если времени прошло меньше, чем нужно - добавляем, больше - новый маршрут

И эта схема вполне себе будет работать. Но можно ее значительно упростить и ускорить, передав ответственность за вычисление разницы по времени на Redis! Как? Обычным Expire. Установим время жизни ключа текущего `маршрута` в 300 секунд, а потом просто будет "спрашивать" у Redis-а: существует или нет текущий `маршрут`.

    redis> SET user:100:current:route "usa50"
    OK
    redis> EXPIRE user:100:current:route 300
    (integer) 1
    redis> GET user:100:current:route
    "usa50" ## Прошло менее 300 секунд с предыдущей SET операции
    redis> GET user:100:current:route
    (nil) ## Прошло более 300 секунд

Обратите внимание, что в этом случае нужно делать SET для текущего маршрута каждый раз при добавлении новой точки (в противном случае, EXPIRE будет считаться от момента создания маршрута).

P.S. В ближайшее время постараюсь привести и "опубликовать" презентацию по Redis-у, а также написать разверную статью об использовании возможностей Redis-а по вычислению пересечения множеств с огромной скоростью и небольшим потреблением памяти.

{% endblock %}

