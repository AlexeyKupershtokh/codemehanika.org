{% extends '_post.html' %}

{% hyde
    title: Практические примеры "нестандартного" использования Redis для решения сложный задач
    created: 2011-07-15
    published: True
    categories: Инфраструктура, Производительность, Redis
    display_in_list: True
    snip: Redis не только супер быстрое key-value storage! (хотя этого у него не отберешь). Встроенные типы данных дают возможность решать с помощью Redis-а те задачи, с которыми очень трудно справиться при использоваии других хранилищ (а иногда и тех задач, которые классически выполняются совсем не хранилищами данных). В этой заметке описано несколько ситуаций из реальной практики разработки, когда Redis неожиданно становился просто-таки спасением
%}

{% block article %}
Вчера на 3й встрече "клуба" Zend_Coffee&Code я рассказывал немного о моделировании хранинения данных и много о возможностях key-value хранилища [Redis](http://redis.io/). К сожалению, получилось как обычно: времени мало, а  материала много. Поэтому рассмотрели, по сути, основы. Это важно, конечно. Но по результатам обсуждения (во время и после встречи) стало понятно: даже имея на руках информацию о том, что умеет Redis, сложно представить себе ситуации, в которых он оказывается просто незаменимым. Я рассказывал о практическом использовании Redis-а у себя в проекте, в этой заметке дополню этот рассказ еще несколькими чисто практическими обзорами.

### 0. Генерирование уникального ID

Это простая задача. И Redis с ней справляется идеально. Чаще всего для обеспечения уникальности ID ресурсов мы используем автоинкрементный поля базы данных. Но не редко подобная роскошь нам недоступна. Как можно использовать Redis для получения Unique ID, например, для нового пользователя?

    redis> SET user:unique 1
    OK
    redis> INCR user:unique
    (integer) 2
    redis> INCR user:unique
    (integer) 3

Идея понятна? Время процессинга такого запроса на Redis-е не превышает 0.01-0.05 мс. Обратите внимание также на то, что операция INCR атомарна, а клиенту отдается инкрементированное значение. А это означает, что уникальность будет обеспечена даже в случае высокой конкурентности запросов (когда ключ инкрементируется огромным количеством клиентов одновременно).

### 1. Рейтинг игроков и столь волнующий вопрос "На каком я месте?"

### 2. Пересечения множеств на чистом С в условиях ограниченной памяти

### 3. Операции, связанные с анализом временных промежутков

Эта ситуация демонстрирует а) как можно избавится от ненужных расчетов в приложении, пользуясь вроде как не для этого созданными фичами хранилища б) как можно "хитрить" со своими данными, ускоряя их обработку.

В общем, представьте себе задачу. У приложения есть `пользователи` (много), которые с мобильного устройства переодически отправляют на наш сервер информацию о своем местонахождении. Отправляют достаточно часто (скажем, 2-3 раза в минуту). Наша задача состоит в том, чтобы собирать из данных об отдельных `точках` в `маршруты`. При этом, если между двумя присланными на сервер `точками` прошло больше 300 секунд, то эти `точки` нужно поместить в разные `маршруты`.

Много пользователей + постоянный пул запросов на запись + слабая зависимость между добавляемыми данными = используем Redis. Пока все очевидно. Идем дальше.

Договоримся, что маршруты будем хранить по ключу вида `user:<userId>:route:<routeId>` в виде списка (LIST) `точек`. Элементами списка должны быть строки (STRING), поэтому будет хранить точку в виде сериализованного на клиенте словаря (dict для Python, array для PHP и т.д.) со значениями `lat`, `lng`, `time`. `userId` известен и определяется аутентификацией мобильного устройства, `routeId` генерируется уникальный для каждого нового `маршрута`.

Пока все просто. Работа с `точками` в `маршрутах` будет выглядеть так:

    redis> RPUSH user:100:route:usa50 "7;8;25" ## Добавляем новые точки "справа"
    redis> RPUSH user:100:route:usa50 "7;9.5;29"
    redis> RPUSH user:100:route:usa50 "7.3;9.5;32"
    redis> LLEN user:100:route:usa50  ## Получить длину маршрута
    redis> LRANGE user:100:route:usa50 0 -1  ## Все точки маршрута
    redis> LINDEX user:100:route:usa50 -1  ## Последняя точка в маршруте


Стандартно. И фокус не в этом. Гораздо интереснее процесс определения на клиенте: в какой маршрут мы должны добавить точку? Фактически это два вопроса: какой маршрут текущий + должны ли мы добавить полученную `точку` в текущий `маршрут` или все-таки создать новый?

Решение "в лоб" заключается в следующем: по специальному ключу `user:<userId>:current:route` будем хранить `<routeId>` текущего маршрута. А далее:

1. при получении новой точки, смотрим текущий маршрут
2. достаем из этого маршрута последнюю точку
3. десериализируем, вычисляем разницу по времени
4. если времени прошло меньше, чем нужно - добавляем, больше - новый маршрут

И эта схема вполне себе будет работать. Но можно ее значительно упростить и ускорить, передав ответственность за вычисление разницы по времени на Redis! Как? Обычным Expire. Установим время жизни ключа текущего `маршрута` в 300 секунд, а потом просто будет "спрашивать" у Redis-а: существует или нет текущий `маршрут`.

    redis> SET user:100:current:route "usa50"
    OK
    redis> EXPIRE user:100:current:route 300
    (integer) 1
    redis> GET user:100:current:route
    "usa50" ## Прошло менее 300 секунд с предыдущей SET операции
    redis> GET user:100:current:route
    (nil) ## Прошло более 300 секунд

Обратите внимание, что в этом случае нужно делать SET для текущего маршрута каждый раз при добавлении новой точки (в противном случае, EXPIRE будет считаться от момента создания маршрута).

{% endblock %}

