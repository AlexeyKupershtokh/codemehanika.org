{% extends '_post.html' %}

{% hyde
    title: Реализация неблокирующего TCP сервера с Tornado
    created: 2011-12-10
    published: True
    categories: Python, Tornado
    display_in_list: True
    snip: "Небольшой и бесхитростный пример кода реализации TCP сервера для мультипользовательской игры в крестики-нолики с использование фреймворка Tornado"
%}

{% block article %}

### Intro

Как-то меня подговорили написать пример создания TCP серверов с помощью [Tornado](http://tornadoweb.org). После недолгих раздумий я решил сделать простую, но не банальную игру в крестики-нолики. Основной функционал заключается в том, что пользователь подключается к tcp порту (например, с помощью telnet), называет имя, под которым он хочет играть, и тем самым или начинает новую игру, или присоединяется к существующей игре в качестве оппонента. Когда игра начинается, система сообщает кто играем крестиками, кто ноликами и кто ходит первым. Далее все происходит итеративно - один ходит, другой ждет получения информации о ходе оппонента. И так либо до попеды одного из участников, либо до ничьей (вся карта занята).

Помимо основного функционала добавил еще возможность указывать размер карты и количество знаков, которые нужно выставить в один ряд. По умолчанию играется стандартная 3x3 до 3х в ряд. На больших картах иногда играть интереснее :) Можно, конечно, было придумать дополнительных плюшек, но код примера и так большой (более 300 строк). При желании и/или необходимости можете дописать что угодно. 

Собственно, ссылка на [gist с кодом](https://gist.github.com/1387470).

### Разбор полетов

Что можно найти в коде примера?

1. Способ создания TCP сервера и общие моменты в определении протокола "общения" клиента и сервера. Сейчас выглядит немного сложновато. Работаю над тем, чтобы со следующей версии Tornado это процедура было попроще (по крайней мере, для стандартных ситуаций). 

2. Логика игры вынесена в отдельный класс. Все остальные действия происходят в инстансах класса протокола, которые создаются в процессе работы ``IOLoop``. Для удобства логика разнесена по Mixin-ам. Это стандартный и весьма удобный способ организации ``tornado``-приложений.

3. Обработка сигналов. Об этом я уже писал в [Tornado server graceful stop](https://gist.github.com/1387470).

4. Асинхронный код в callback-стиле. В основном асинхронность реализована на операциях чтение/записи в tcp stream. Внимание! Очень аккуратно с записью. Операция записи в поток также асинхронна, как и операция чтения. На этом часто делаются ошибки. Т.е. код

    self.stream.write('%s, your step pls\n' % self.name)
    self.stream.read_until(b('\n'), self._on_step)

Сработает не так, как выглядит с первого взгляда :) Конечно, можно было большую часть оформить с помощью ``gen.Task`` и ``gen.Callback``. Но я решил, что подробнее о [модуле tornado.gen](http://www.tornadoweb.org/documentation/gen.html) напишу в отдельной заметке. 

5. [``tornado.stack_context``](http://www.tornadoweb.org/documentation/stack_context.html) необходим для реализации перехвата Exception-ов при асинхронной обработке. На самом деле, это "низкоуровневая" деталь реализации ``tornado`` и в типичных ситуациях вы не должны о ней задумываться. Стандартные ``callback`` будут обернуты в ``StackContext`` без вашего ведома (например, при передаче callback-а в функции ``stream.write``/``stream.read_*``). Но иногда возникают ситуации, когда забывать о контексте нельзя. В моем случае, это работа с register-callback:

    def register(self, on_register=None):
        """Register player with using text name"""
        if on_register:
            self._register_callback = stack_context.wrap(on_register)
        else: 
            self._register_callback = None
        self.stream.write('Enter your name: ', callback=self._on_greeting)

Вообще, работа с Exception-ами в асинхронном коде тема обширная, и также заслуживает отдельной заметки.

6. Работа с параметрами командной строки. Показана работа связки ``define``/``parse_command_line``/``options``. Ничего хитрого, по коду примера легко разобраться что и как работает. Один только комментарий хочу добавить - вызов ``parse_command_line`` переопределит root-овый logger объект (если быть совсем точным, то ``tornado`` выполнит [``enable_pretty_logging``](https://github.com/facebook/tornado/blob/master/tornado/options.py#L321)).

7. Мелочи.

P.S. Код не претендует на финальность или абсолютную граммотность. Более того, код примера написан на скорую руку и я с удовольствием приму советы/подсказки по его улучшению. 

{% endblock %}